############ Adapted functions from Cardinal for binning matrix objects ############


#' This function bins spectral data generated by cardinal into a Matrix object (rather than a matter object)
#'
#' @param x The spectral data to be binned, typically a matrix or data frame.
#' @param ref A vector of reference mass-to-charge (m/z) values for binning. If left unspecified, mass range will be used to generate reference peaks.
#' @param spectra Character string specifying the column name for spectral intensity values (default = "intensity").
#' @param index Character string specifying the column name for the m/z values (default = "mz").
#' @param method A character vector specifying the binning method. Options include `"sum"`, `"mean"`, `"max"`, `"min"`, `"linear"`, `"cubic"`, `"gaussian"`, and `"lanczos"`. If not specified default method used is "sum".
#' @param resolution Numeric value specifying the resolution for binning. If assigned as `NA`, the resolution will be automatically caculated based on the data (default = NA).
#' @param tolerance Numeric value specifying the tolerance for m/z matching (default = `NA`).
#' @param units Character string specifying the units for resolution. Options are `"ppm"` or `"mz"` (default = "ppm").
#' @param mass.range Numeric vector of length two specifying the lower and upper bounds of the mass range for binning. If set to NULL will use the entire range to bin (default = NULL).
#'
#' @return A binned spectral data object with the same structure as the input, but with modified spectral data according to the specified binning parameters.
#' @export
#'
#' @import Cardinal
#' @import matter
#'
#' @examples
#' # used as a helper function for LoadSM
bin_cardinal <-	function(x, ref,
                         spectra = "intensity", index = "mz",
                         method = c("sum", "mean", "max", "min",
                                    "linear", "cubic", "gaussian", "lanczos"),
                         resolution = NA, tolerance = NA, units = c("ppm", "mz"),
                         mass.range = NULL)
{
  if ( !is.null(mass.range) ) {
    if ( is.na(resolution) )
      stop("setting 'mass.range' requires setting 'resolution'")
    ref <- mass.range
  }
  if ( !missing(ref) ) {
    if ( is(ref, "MSImagingExperiment") || is(ref, "MassDataFrame") )
      ref <- mz(ref)
  }
  if ( missing(units) && !missing(resolution) )
    units <- get_units_from_names(resolution, units)

  if (!units %in% c("ppm", "mz")){
    stop("incorrect unit value! units must = either 'ppm' or 'mz'. Please change units accordingly ...")
  }

  units <- ifelse(units == "ppm", "relative", "absolute")

  if ( !is.na(resolution) )
    resolution <- switch(units,
                         relative=1e-6 * resolution,
                         absolute=resolution)
  if ( !is.na(tolerance) )
    tolerance <- ifelse(units == "relative",
                        1e-6 * tolerance,
                        tolerance)

  ans <- bin_SpectralImagingExperiment(x = x, ref=ref, spectra=spectra, index=index,
                                       method=method, resolution=resolution, tolerance=tolerance, units=units)


  return(ans)
}




#' Function used to generate a binned intensity matrix based on reference peaks generated via Cardinal
#'
#' @param x The spectral data to be binned, typically a matrix or data frame.
#' @param ref A vector of reference mass-to-charge (m/z) values for binning. If left unspecified, mass range will be used to generate reference peaks.
#' @param spectra Character string specifying the column name for spectral intensity values (default = "intensity").
#' @param index Character string specifying the column name for the m/z values (default = "mz").
#' @param method A character vector specifying the binning method. Options include `"sum"`, `"mean"`, `"max"`, `"min"`, `"linear"`, `"cubic"`, `"gaussian"`, and `"lanczos"`. If not specified default method used is "sum".
#' @param resolution Numeric value specifying the resolution for binning. If assigned as `NA`, the resolution will be automatically caculated based on the data (default = NA).
#' @param tolerance Numeric value specifying the tolerance for m/z matching (default = `NA`).
#' @param units Character string specifying the units for resolution. Options are `"ppm"` or `"mz"` (default = "ppm").
#' @param verbose Boolean indicating whether to show the message. If TRUE the message will be show, else the message will be suppressed.
#'
#' @return Matrix object which has binned intensity values.
#' @export
#'
#' @import Cardinal
#' @import matter
#'
#' @examples
#' #Helper function for binning data in Matrix format
bin_SpectralImagingExperiment <- function(x, ref,
                                          spectra = "intensity", index = NULL,
                                          method = c("sum", "mean", "max", "min",
                                                     "linear", "cubic", "gaussian", "lanczos"),
                                          resolution = NA, tolerance = NA, units = c("relative", "absolute"),
                                          verbose = getCardinalVerbose())
{
  method <- match.arg(method)
  if ( length(index) > 1L )
    stop("more than 1 'index' array not allowed")
  if ( missing(units) && !missing(resolution) )
    units <- get_units_from_names(resolution, units)
  units <- match.arg(units)
  snm <- spectra
  inm <- index
  spectra <- spectra(x, snm)

  if ( is.null(inm) ) {
    inm <- "index"
    domain <- seq_len(nrow(x))
  } else {
    domain <- data.frame(Cardinal::featureData(x))[[inm]]
    if ( is.null(domain) )
      stop("index ", inm, " not found")
  }
  if ( is.sparse(spectra) ) {

    index <- atomindex(spectra)
    #spectra <- atomdata(spectra)
  } else {
    index <- rep.int(list(domain), ncol(x))
  }

  res.ref <- switch(units, relative="x", absolute="abs")
  if ( is.na(resolution) ) {
    if ( missing(ref) || is.null(ref) ) {
      res <- estres(domain, ref=res.ref)
    } else {
      res <- estres(ref, ref=res.ref)
    }
  } else {
    res <- setNames(resolution, units)
    if ( !missing(ref) && !is.null(ref) )
      ref <- switch(units,
                    relative=seq_rel(min(ref), max(ref), by=res),
                    absolute=seq.default(min(ref), max(ref), by=res))
  }

  if ( missing(ref) || is.null(ref) ) {
    from <- floor(min(domain))
    to <- ceiling(max(domain))
    ref <- switch(units,
                  relative=seq_rel(from, to, by=res),
                  absolute=seq.default(from, to, by=res))
  }
  if ( is.na(tolerance) ) {
    if ( method %in% c("sum", "mean", "max", "min") ) {
      tol <- 0.5 * res
    } else {
      tol <- 2 * res
    }
    from <- round(min(ref), digits=4L)
    to <- round(max(ref), digits=4L)
    #.Log("binning ", snm, " from ", inm, " ", from, " to ", to,
    #	" with ", units, " resolution ", round(res, digits=6L),
    #	message=verbose)
  } else {
    label <- if (length(ref) != 1L) "references" else "reference"
    #.Log("binning ", snm, " to ", length(ref), " ", inm, " ", label,
    #	" with ", units, " tolerance ", round(tolerance, digits=6L),
    #	message=verbose)
    tol <- setNames(tolerance, units)
  }

  all_identical <- all(sapply(index[1:length(index)], identical, index[[1]]))

  if (all_identical) {
    message("All m/z values are identical between pixels ... ")
    index <-  index[[1]]
  } else {
    warning("Some m/z values are different between pixels ... SpaMTP will use the first list of indexes to bin data! If this is unwanted please set binning_function = 'Cardinal'")
    index <-  index[[1]]
  }

  verbose_message(message_text = "Converting matter matrix to Matrix ... ", verbose = verbose)

  mat <- as.matrix(Cardinal::spectra(x))

  if ( length(index) <= length(ref)){
    rownames(mat) <- index
    return(mat)
  } else {
    return(spectral_binning(matrix=mat, ref = ref, index = index, method = method, tolerance = tol))
  }
}




#' Spectral binning of intensity values stored in a Matrix object, converted from matter.
#'
#' @param matrix matter matrix object containing the intensity values to be binned.
#' @param ref A vector of reference mass-to-charge (m/z) values for binning. If left unspecified, mass range will be used to generate reference peaks.
#' @param index Character string specifying the column name for the m/z values (default = "mz").
#' @param method A character vector specifying the binning method. Options include `"sum"`, `"mean"`, `"max"`, `"min"`. If not specified default method used is "sum".
#' @param tolerance Numeric value specifying the tolerance for m/z matching (default = `NA`).
#'
#' @return Matrix object containing the binned intensity values matching the provided reference list.
#' @export
#'
#' @examples
#' #Helper function for binning data in Matrix format
spectral_binning <- function(matrix, ref, index, method = c("sum", "mean", "max", "min"), tolerance) {
  # Ensure method is valid
  method <- match.arg(method)

  # Validate inputs
  if (!is.matrix(matrix)) {
    stop("'matrix' must be a numeric matrix")
  }
  if (is.null(ref) || length(ref) == 0) {
    stop("'ref' (reference bins) must be provided")
  }
  if (is.null(tolerance) || tolerance <= 0) {
    stop("'tolerance' must be a positive number")
  }

  # Initialize binned matrix
  binned_matrix <- matrix(0, nrow = length(ref), ncol = ncol(matrix))
  #return(binned_matrix)
  # Perform binning

  if(names(tolerance) == "relative"){
    for (i in seq_along(ref)) {
      # Calculate relative tolerance bounds
      lower_bound <- ref[i] - (ref[i] * tolerance)
      upper_bound <- ref[i] + (ref[i] * tolerance)

      # Identify rows (spectral features) within the current bin
      in_bin <- which(index >= lower_bound & index <= upper_bound)

      if (length(in_bin) > 0) {
        # Apply the chosen method to bin the data
        binned_matrix[i, ] <- switch(method,
                                     sum = colSums(matrix[in_bin, , drop = FALSE]),
                                     mean = colMeans(matrix[in_bin, , drop = FALSE]),
                                     max = apply(matrix[in_bin, , drop = FALSE], 2, max),
                                     min = apply(matrix[in_bin, , drop = FALSE], 2, min))
      }
    }
  } else{

    for (i in seq_along(ref)) {

      # Define the bin range for the current reference value
      lower_bound <- ref[i] - tolerance
      upper_bound <- ref[i] + tolerance

      # Identify rows (spectral features) within the current bin
      in_bin <- which(index >= lower_bound & index <= upper_bound)

      if (length(in_bin) > 0) {
        # Apply the chosen method to bin the data
        binned_matrix[i, ] <- switch(method,
                                     sum = colSums(matrix[in_bin, , drop = FALSE]),
                                     mean = colMeans(matrix[in_bin, , drop = FALSE]),
                                     max = apply(matrix[in_bin, , drop = FALSE], 2, max),
                                     min = apply(matrix[in_bin, , drop = FALSE], 2, min))
      }
    }
  }

  # Set row names to the reference values
  rownames(binned_matrix) <- as.character(ref)

  return(binned_matrix)
}




#' Bins m/z peaks of a SpaMTP object.
#'
#' @param data SpaMTP Seurat Object containing the intensity data to be binned
#' @param resolution Numeric value indicating the relative bin size to use when binning the intensity data.
#' @param units Character string defining the relative units of the provided resolution size. Values can be either 'ppm' or 'mz' (default = 'ppm').
#' @param assay Character string defining the SpaMTP assay to extract intensity values from (default = "Spatial").
#' @param slot Character string defining the assay slot containing the intensity values (default = "counts").
#' @param method A character vector specifying the binning method. Input values must be either `"sum"`, `"mean"`, `"max"` or `"min"` (default = "sum").
#' @param return.only.mtx Boolean value indicating whether to return only the binned intensity matrix. If `FALSE`, a SpaMTP object will be returned with the binned values stored in an assay called `binned` (default = FALSE).
#'
#' @return Either a binned intensity matrix or a SpaMTP object contatining the binned intensity matrix stored in the `binned` assay.
#' @export
#'
#' @examples
#' #BinSpaMTP(spamtp.obj, resolution = 10, units = "ppm", return.only.mtx = TRUE)
BinSpaMTP <- function(data, resolution, units = "ppm", assay = "Spatial",slot = "counts", method = c("sum"), return.only.mtx = FALSE){

  orignal_bin_size <- resolution
  min_ref <- min(data[[assay]]@meta.data$raw_mz)
  max_ref <- max(data[[assay]]@meta.data$raw_mz)

  if (units == "ppm"){
    resolution <- 1e-6 * resolution
    bin_class <- "relative"
  } else if ( units == "mz"){
    bin_class <- "absolute"
  } else {
    stop("Incorrect units provided! units must be either 'ppm' or 'mz'. Please use either option for binning")
  }


  if(bin_class == "relative"){
    ref <- seq_rel(min_ref, max_ref, by=resolution)
  } else {
    ref <- seq.default(min_ref, max_ref, by=resolution)
  }

  if ( method %in% c("sum", "mean", "max", "min") ) {
    tol <- 0.5 * resolution
  } else {
    tol <- 2 * resolution
  }

  names(tol) <- bin_class
  index <- data[[assay]]@meta.data$raw_mz

  if (length(ref) < length(index)){
    mtx <- spectral_binning(matrix=as.matrix(data[[assay]][slot]), ref = ref, index = index, method = method, tolerance = tol)
    colnames(mtx) <- rownames(data@meta.data)
  } else {
    warning("Bin size is too small to bin m/z values together. Currently, with a bin size of ",
            orignal_bin_size, " ", units, " No m/z values will be binned together ... The original intensity matrix will be used!")
    mtx <- data[[assay]][slot]
  }


  if (return.only.mtx){
    return(mtx)
  } else {
    obj <- SeuratObject::CreateAssayObject(counts = mtx)
    data[["binned"]] <- obj
    return(data)
  }
}




