---
title: "SpaMTP_Additional_Features"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SpaMTP_Additional_Features}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


This vignette will highlights some additional features of [***SpaMTP***](https://github.com/GenomicsMachineLearning/SpaMTP) that can be useful for analysing and visualusing your SM data. This vignette will again use the public mouse urinary bladder dataset analysed extensively [here](https://genomicsmachinelearning.github.io/SpaMTP/articles/Mouse_Urinary_Bladder.html).

Author: Andrew Causer

```{r load_packages, warning=FALSE, message=FALSE}
## Install SpaMTP if not previously installed
if (!require("SpaMTP"))
    devtools::install_github("BiomedicalMachineLearning/SpaMTP")

#General Libraries
library(SpaMTP)
library(Cardinal)
library(Seurat)
library(dplyr)

#For plotting + DE plots
library(ggplot2)
library(EnhancedVolcano)
```


#### Load Processed Data

Here we will be using already processed, clustered (via spatially-aware Shrunken Centroid) and annotated data. For more infomation about how the data was processed please visit [here](https://genomicsmachinelearning.github.io/SpaMTP/articles/Mouse_Urinary_Bladder.html).

```{r warning=FALSE, message=FALSE}
bladder_annotated <- readRDS("vignette_data_files/Mouse_Urinary_Bladder/bladder_annotated.RDS")
```    

<br>

## Querying an ***SpaMTP*** Dataset 

***SpaMTP*** stores the relative m/z value annotations in the objects feature metadata slot. We can see this below:

```{r warning=FALSE, message=FALSE}
head(bladder_annotated@assays$Spatial@meta.data)
```  

However, there is are some useful functions that lets the user search through their ***SpaMTP** dataset to find either exact m/z values or metabolite names that they are interested in. Lets see how each works:

The first is *FindNearestMZ()*, this function lets uses find the m/z value in their dataset that is closest to the value being queried.

```{r warning=FALSE, message=FALSE}
FindNearestMZ(bladder_annotated, 741.5)
```  

This is useful if the metabolite of interest has a known m/z mass, or if the user wants to use *Seurat's* feature plotting functions. 

The second is *SearchAnnotations()*, this function lets query a metabolite to find if it is present within their dataset. 

```{r warning=FALSE, message=FALSE}
SearchAnnotations(bladder_annotated, metabolite = "Isorhamnetin 3-(6''-malonylglucoside)", search.exact = TRUE)
```  

The `search.exact` parameter specifies whether there needs to be an exact match to the metabolite name. If set to `FALSE`, users can find all metabolites with similar names. For example we want to see all the different types of `(3'-sulfo)Galbeta-Cer` lipids in our dataset.

```{r warning=FALSE, message=FALSE}
SearchAnnotations(bladder_annotated, metabolite = "(3'-sulfo)Galbeta-Cer", search.exact = FALSE)
``` 

This function also lets users select the feature metadata column they want to Query. For example, if *RefineLipis()* has been run users can search for all lipids of the Class "GlcCer". 

```{r warning=FALSE, message=FALSE}
SearchAnnotations(bladder_annotated, metabolite = "GlcCer", search.exact = FALSE, column.name = "Lipid.Maps.Main.Class")
``` 

## Subsetting a ***SpaMTP*** Dataset by Metabolites

In some cases, we may want to reduce the number of features present in our dataset. Often there are thousands or millions of metabolites in one dataset, removing unwanted metabolites can often reduce the computational load. Below we demonstrate how to subset our bladder dataset to only include Glycerophospholipids.

```{r warning=FALSE, message=FALSE}

GPs <- SearchAnnotations(bladder_annotated, metabolite = "GP", search.exact = FALSE, column.name = "Lipid.Maps.Category")

bladder_GPs <- SubsetMZFeatures(bladder_annotated, features = GPs$mz_names)
```

```{r warning=FALSE, message=FALSE}
bladder_annotated
``` 
```{r warning=FALSE, message=FALSE}
bladder_GPs
``` 
We can see that we now only have 33 features, compared to the 79 from the original dataset. 


## Visualising SM data using ***SpaMTP***

An important part of any analysis pipeline is to generate informative and clear visualisations of the results. ***SpaMTP*** has a range of visualisation functions and features which we will step through below.


### Plotting a m/z Value

Plotting in ***SpaMTP*** builds on *ggplot2* allowing for easy organisation and plot manipulation. Below we will plot the expression of the m/z 741.530578613281 using *Seurat's* plotting function *ImageFeaturePlot()*. Below we use ggplot helper functions to orientate the image correctly.  

```{r, fig.width=11, fig.height=5, warning=FALSE, message=FALSE}
ImageFeaturePlot(bladder_annotated, features = "mz-741.530578613281", size = 2) & 
  coord_flip() & 
  scale_x_reverse()
```


Comparatively, the ***SpaMTP*** function *ImageMZPlot()* provides more SM-based functionality, including:
* Plotting the closest m/z value to the numeric value provided.
* Plotting the combined expression of &#177; the mz value in ppm
* Plotting the spots as either circles (*ST*) or pixels (*SM*)

```{r, fig.width=11, fig.height=5, warning=FALSE, message=FALSE}
ImageMZPlot(bladder_annotated, mz = 741.53057, plusminus = 1, size = 1, plot.pixel = TRUE) & 
  coord_flip() & 
  scale_x_reverse()
```

### Plotting a Metabolite Name

In addition, ***SpaMTP*** also has a function *ImageMZAnnotationPlot()* which allows users to plot the spatial expression of named metabolites. In addition to the features above, this function also lets users:
* Plot from a specific column in the feature metadata containing the m/z metabolite annotations
* Combine the expression of all metabolites that match the specified name (as described above using plot.exact = `FALSE`). 

We will use the "Galbeta-Cer" metabolites as an example:

```{r, warning=FALSE, message=FALSE}
mb <- (SearchAnnotations(bladder_annotated, metabolite = "Galbeta-Cer", search.exact = FALSE))$all_IsomerNames

mb
```

Lets plot them individually

```{r, fig.width=22, fig.height=5, warning=FALSE, message=FALSE}
ImageMZAnnotationPlot(bladder_annotated, metabolites = c("(3'-sulfo)Galbeta-Cer(d18:1/22:0(2OH))", "(3'-sulfo)Galbeta-Cer(d18:1/24:0(2OH))"), slot = "counts", plot.exact = FALSE, size = 1.5) & coord_flip() & 
  scale_x_reverse()
```

Lets plot them combined
```{r, fig.width=11, fig.height=5, warning=FALSE, message=FALSE}
ImageMZAnnotationPlot(bladder_annotated, metabolites = "Galbeta-Cer", slot = "counts", plot.exact = FALSE, size = 1.5) & coord_flip() & 
  scale_x_reverse()
```

There are equivalent functions for ***SpaMTP*** *Seurat* objects that contain images these being *SpatialMZPlot()* and *SpatialMZAnnotationPlot()*. Examples of these are shown below.    


### Plotting Mass Intensity Spectra Plots

Often we are interested in different patterns of metabolite expression between groups such as clusters. Mass intensity plots can be useful at displaying the overall patters of each tissue region. ***SpaMTP*** provides functionality to generate these plots and also label peaks with selected metabolites. 


```{r, fig.width=20, fig.height=5, warning=FALSE, message=FALSE}

ROI <- subset(bladder_annotated, subset = ssc %in% c("2", "5", "6")) 

p <- MassIntensityPlot(ROI, group.by = "ssc", label.annotations = TRUE, metabolite.labels = c("PC(34:1)"), annotation.column = "Species.Name.Simple")
              
```

Based on this plot we can see that our metabolite "PC(34:1)" has been annotated on the plot. The plot looks quite crowded though. We can either change the mass range to only show the specific region on the spectrum, or we could generate indiviudal plots for each cluster. We will show both approachs below:

Change the mass range:
```{r, fig.width=20, fig.height=5, warning=FALSE, message=FALSE}
p <- MassIntensityPlot(ROI, group.by = "ssc", mass.range = c(750, 850), label.annotations = TRUE, metabolite.labels = c("PC(34:1)"), annotation.column = "Species.Name.Simple")
```

Generate indiviudal plots per cluster:
```{r, fig.width=20, fig.height=10, warning=FALSE, message=FALSE}
p <- MassIntensityPlot(ROI, split.by  = "ssc", label.annotations = TRUE, metabolite.labels = c("PC(34:1)"), annotation.column = "Species.Name.Simple")
```

Now we can clearly see that this metabolite is highly expressed by cluster 6!


There are various additional visualisation techniques such as 3D Density Kernel plotting and various DE and pathway analysis plotting functions. These can all bee seen in either the [SM data analysis]https://genomicsmachinelearning.github.io/SpaMTP/articles/Mouse_Urinary_Bladder.html) or [Multi-Omic data](https://genomicsmachinelearning.github.io/SpaMTP/articles/Multi-Omic_Mouse_Brain.html) analysis vingettes.


## Binning Metabolites

Expression of specific metabolites on their own can sometime be difficult to detect, however when combining the expression of similar metabolites these patterns can become more observable. ***SpaMTP*** has the function *BinMetabolites()* which lets users specify the metabolites they want to combine the expression of. These values are then stored in the `@metadata` slot of the ***SpaMTP*** *Seurat* object and can be plotted or used for further analysis. Below we will demonstrate how to bin the expression of all Glycerophospholipids. 

```{r warning=FALSE, message=FALSE}
mzs <- SearchAnnotations(bladder_annotated, metabolite = "GP", search.exact = FALSE, column.name = "Lipid.Maps.Category")$mz_names

bladder_annotated <- BinMetabolites(bladder_annotated, mzs = mzs, assay = "Spatial", slot = "counts", bin_name = "Binned_GPs")

head(bladder_annotated@meta.data)
```
We can see the expression values have been stored in the `@meta.data` column "Binnde_GPs". Now lets plot the results:

```{r, fig.width=11, fig.height=5, warning=FALSE, message=FALSE}
ImageFeaturePlot(bladder_annotated, features = "Binned_GPs", size = 2) & 
  coord_flip() & 
  scale_x_reverse() & scale_fill_gradientn(colors = viridis::viridis(100))
```

We can see that there is high expression of GP's in the urothelium and adventitia layers of the bladder. This feature is especially usefull to combine metabolites that are all up expressed in a specific condition/cluster (following differential expression analysis).



## Adding H&E Image to Spatial Metabolomic Data

One useful feature of ***SpaMPT*** is the ability to add a H&E or tissue image to the *SpaMTP* object. This can allow the user to visualise key structural metabolic patterns that match to the tissue morphology. Below we will demonstrate how to manually align your image with your SM dataset. 

```{r, eval=FALSE}
bladder_HE <- AddSMImage("vignettes/vignette_data_files/Mouse_Urinary_Bladder/mouse_urinary_bladder_HE.tif", bladder_annotated, msi.pixel.multiplier = 2)
```


This function will activate an interactive window where you can change the MSI coordinates to align to the image provided. This includes rotation, adjusting x and y coordinates, flipping around the x or y axis, and also scaling. The user can also select any column in the object's metadata to plot. This can help assist the alignment process, in particular by using clustering results.  

Here is an example of what the alignment GUI looks like, and also the perimeters we used to align the H&E image:

```{r echo=FALSE, fig.align="center", out.width="100%"}
knitr::include_graphics("vignette_data_files/Mouse_Urinary_Bladder/H&E_Alignment.png")
```

After clicking the return aligned data button a ***SpaMTP*** *Seurat* object with the H&E image added to the `@image$slice1` slot will be returned. Here "fov" is the original SM plotting coordinates and "slice1" has the adjusted coordinates to match the H&E image.

```{r, include=FALSE}
bladder_HE <- readRDS("vignette_data_files/Mouse_Urinary_Bladder/bladder_HE.RDS")
```  

```{r fig.width=30, fig.height=5, warning=FALSE, message=FALSE}
bladder_HE@images
```

Lets now visualise this:

```{r fig.width=20, fig.height=10, warning=FALSE, message=FALSE}
(ImageDimPlot(bladder_HE, group.by = "ssc", fov = "fov", size = 1) & scale_y_reverse() )/ 
  (SpatialDimPlot(bladder_HE, group.by = "ssc", images = "slice1", pt.size.factor = 3) &theme_void())
```


This also means that we can now visualise our data using the *Plot3D()* function with a H&E image:

```{r, fig.width=10, fig.height=10, warning=FALSE, message=FALSE}
### Identified the m/z values that are to be plot
mzs <- unlist(lapply(c(798.5411, 741.5306), function(x) FindNearestMZ(data = bladder_annotated, target_mz = x)))
ROI_HE <- subset(bladder_HE, subset = ssc %in% c("2", "5", "6"))

#Plot3DFeature(ROI_HE, features = mzs, show.image = "slice1", assays = "Spatial", between.layer.height = 200, names = c("PC(34:1)","SM(34:1)"), plot.height = 400, plot.width = 800)
                     
```

```{r, fig.width=10, fig.height=10, warning=FALSE, message=FALSE}
library(plotly)
data <- ROI_HE
assays = c("SPT", "SPM")
slots = "counts"
between.layer.height = 100
names= NULL
col.palette = "Reds"
x.axis.label = "x"
y.axis.label = "y"
z.axis.label = "z"
show.x.ticks = FALSE
show.y.ticks = FALSE
show.z.ticks = FALSE
show.image = NULL
plot.height = 800
plot.width = 1500
image.sf = "lowres"
features = mzs
show.image = "slice1"
assays = "Spatial"
between.layer.height = 200
names = c("PC(34:1)","SM(34:1)")
plot.height = 400
plot.width = 800

if (length(features) ==  1 ){
    features <- c(features, features)
  }
  if (length(assays) ==  1 ){
    assays <- c(assays, assays)
  }
  if (length(slots) ==  1 ){
    slots <- c(slots, slots)
  }
  if (length(col.palette) ==  1 ){
    col.palette <- c(col.palette, col.palette)
  }



 feature_data <- list()

  i <- 1
  default_names <- c()
  for (feature in features) {

    if (feature %in% colnames(data@meta.data)){
      default_names <- c(default_names, feature)
      feature_data[[i]] <- data@meta.data[[feature]]
    } else {
      if (length(assays) != 0){

        feature_data[[i]] <- tryCatch({data[[assays[i]]][slots[i]][feature,]},
                                      error = function(err){
                                        stop("The feature provided does not exist in the ", assays[i],": ",slots[i], " object. Please provide a value feature")})
      } else {
        stop("No assay supplied. The feature ", feature," either does not exist in @meta.data slot, or no matching assay was provided for the gene/feature. Please check SpaMTP object")
      }
      default_names <- c(default_names, paste0(feature,"_", assays[i]))
    }
    i <- i + 1
  }
  if (!(is.null(names))){
    if (length(names) == 2) {
      default_names <- names
    } else {
      warning("length of names must be == 2. Default names will be used instead ... ")
    }
  }

trace1 <-
    plot_ly(GetTissueCoordinates(data),
            x = ~x,
            y = ~y,
            z = rep(0 + between.layer.height, times = dim(GetTissueCoordinates(data))[1]),
            type = "scatter3d",
            mode = "markers",
            height = plot.height,
            width = plot.width,
            name = default_names[1],
            marker = list(color = feature_data[[1]],
                          coloraxis = 'coloraxis', size = 3)) %>%
    layout(scene = list(
      aspectmode = "data",
      xaxis = list(title = x.axis.label, showticklabels = show.x.ticks),
      yaxis = list(title = y.axis.label, showticklabels = show.y.ticks),
      zaxis = list(title = z.axis.label, showticklabels = show.z.ticks)))

  plot <-  trace1 %>% add_trace(GetTissueCoordinates(data),
                                x = ~x,
                                y = ~y,
                                z = rep(0, times = dim(GetTissueCoordinates(data))[1]),
                                type = "scatter3d",
                                mode = "markers",
                                name = default_names[2],
                                marker = list(color = feature_data[[2]],
                                              coloraxis = 'coloraxis2')) %>% layout(autosize = F,
      scene = list(
        aspectmode = "data",
        xaxis = list(title = x.axis.label, showticklabels = show.x.ticks),
        yaxis = list(title = y.axis.label, showticklabels = show.y.ticks),
        zaxis = list(title = z.axis.label, showticklabels = show.z.ticks)),
      coloraxis = list(colorbar = list(orientation = "v",
                                       xanchor ="right",
                                       x = 0,
                                       len = 0.5,
                                       title = list( side = "top",
                                                     text = default_names[1]
                                       )),
                       colorscale = col.palette[1]),
      coloraxis2 = list(colorbar = list(orientation = "v",
                                        xanchor ="left",
                                        len = 0.5,
                                        x = 0,
                                        title = list( side = "top",
                                                      text = default_names[2]
                                        )),
                        colorscale = col.palette[2])

    )
  
  
sampled_df <- df[sample(nrow(df), 0.05 * nrow(df)), ]

# To maintain some visual structure, sort by row and column after sampling
sampled_df <- sampled_df[order(sampled_df$row, sampled_df$col), ]

p1 <- plot%>% plotly::add_trace(sampled_df,
               x = sampled_df$row / ROI_HE@images[["slice1"]]@scale.factors[["lowres"]],
               y = sampled_df$col / ROI_HE@images[["slice1"]]@scale.factors[["lowres"]],
               z = rep(0 - 200, times = dim(sampled_df)[1]),
               type = "scatter3d",
               mode = "markers",
               name = "H&E",
               marker = list(color = sampled_df$color))

p1

#print(dim(sampled_df)[1]+length(feature_data[[1]])+length(feature_data[[2]]))
```



## Data Export

Data export can often be difficult when dealing with large datasets of different data object types such as *R's Seurat* compared to *Python's scanpy*. ***SpaMTP*** can easily export the data object in matrix.mtx, barcodes.csv and features.csv files which can be easily read in to all major spatial analysis packages. In addition cell/pixel and feature metadata is also exported as .csv files. Below we demonstrate how to export the files

```{r, eval=FALSE}
saveSpaMTPData(bladder_annotated, outdir = "../Documents/SpaMTP_Output/", assay = "Spatial", slot = "counts", annotations = TRUE)
```














